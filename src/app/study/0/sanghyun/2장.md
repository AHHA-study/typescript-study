---
marp: true
---

# 2장 타입스크립트의 타입 시스템
타입 시스템에 대해 알아본다.

---

## 아이템 6 편집기를 사용하여 타입 시스템 탐색하기
TS를 설치하면 실행할 수 있는 것
- TS 컴파일러(tsc)
- 단독으로 실행할 수 있는 TS 서버 (tsserver)

보통은 컴파일러를 실행하는 것이 주된 목적이지만, TS 서버 또한 코드 자동완성, 명세 검사, 검색, 리팩터링 등을 포함하는 '언어 서비스'를 제공하기 때문에 중요하다.

---

### 요약
- 편집기에서 TS 언어 서비스를 적극 활용해야 한다.
편집기를 사용하면 어떻게 타입 시스템이 동작하는지, TS가 어떻게 타입을 추론하는지 개념을 잡을 수 있다.
- TS가 동작을 어떻게 모델링하는지 알기 위해 타입 선언 파일을 찾아보는 방법을 터득해야 한다.

---

## 아이템 7 타입이 값들의 집합이라고 생각하기

- 런타임에 모든 변수는 값을 가진다.
- 런타임 이전에 변수는 타입을 가진다.

---

### 타입은 집합으로 볼수 있다.

- number: 12, 48.29 등등
- string: 'a', 'aawef' 등등
- never: 공집합
- 이외의 타입도 해당 방식으로 나타낼 수 있다.

---

### 유니온 타입은 합집합이다.

유니온 타입은 여러개의 타입을 하나로 묶기 위한 방법이다.
```TypeScript
type AB = 'A' | 'B';
type AB12 = 'A' | 'B' | 12;
```
`|` 를 사용해 나타내고, 사용할수록 타입의 범위가 넓어진다.

---

### 타입에 값을 할당 가능하다 === 해당 타입의 부분집합이다
```TypeScript
type AB = 'A' | 'B';

const A: AB = 'A';
const B: AB = 'B';
```

---

중간에 없는 아이템 나중에 채워넣기

---

## 아이템 11 잉여 속성 체크의 한계 인지하기

타입이 명시된 변수에 객체 리터럴을 할당한다.
- TS가 해당 타입의 속성이 있는지 확인한다.
- TS가 그 외의 속성이 없는지 확인한다.

---

에러난다!
```TypeScript
interface Room {
  numDoors: number;
  ceilingHeightFt: number;
}
const r: Room = {
  numDoors: 1,
  ceilingHeightFt: 10,
  elephant: 'present',
  // 개체 리터럴은 알려진 속성만 지정할 수 있으며
  // 'Room' 형식에 'elephant'이(가) 없습니다.
}
```

---

구조적 타이핑 관점으로 생각해보면 오류는 발생하지 않아야 하는데...
```TypeScript
const obj = {
  numDoors: 1,
  ceilingHeightFt: 10,
  elephant: 'present',
};

const r: Room = obj; // 정상
```
그렇다! 리터럴이라 당했다!

---

### 잉여 속성 체크

**객체 리터럴**에 수행되며 다음과 같은 특징을 갖는다.
- 객체 리터럴에 알 수 없는 속성을 허용하지 않는다.
- 객체 리터럴에 타입 단언문을 사용하면 수행되지 않는다.
  - 단언문보다 선언문을 사용해야 하는 이유 중 하나
- 만약 체크를 원치 않는다면, 인덱스 시그니처를 사용한다.

---

### 인덱스 시그니처는 잉여 속성 체크에 걸리지 않는다.

```TypeScript
interface Options {
  darkMode?: boolean;
  [otherOptions: string]: unkown;
}

const o: Options = { darkmode: true } // 정상
```

---

### 공통 속성 체크

약한 타입의 경우 공통된 속성이 있는지 확인하는 별도의 체크를 수행한다.
```TypeScript
interface LineChartOptions {
  logScale?: boolean;
  invertedYAxis?: boolean;
  areaChart?: boolean;
}
const ops = { logScale: true };
const o: LineChartOptions = opts;
// '{ logScale: boolean; }' 유형에
// 'LineChartOptions' 유형과 공통적인 속성이 없습니다.
```

---

## 아이템 12 함수 표현식에 타입 적용하기
JS에서 함수 선언과 표현식은 다르다.
```Javascript
function rollDice1(sides: number): number { ... } // 선언
const rollDice2 = function(sides: number): number { ... } // 표현식
const rollDice3  = (sides: number): number => { ... } // 표현식
```
TS 에서는 함수 표현식을 사용하는 것이 좋다.
```TypeScript
// 함수 전체를 타입으로 선언하여 재사용할 수 있기 때문이다.
type DiceRollFn = (sides: number) => number;
const rollDice: DiceRollFn = sides => { ... }
```

---

### 반복되는 함수 시그니처를 하나의 함수 타입으로 통합할 수도 있다.
```Typescript
// 이랬는데
function add(a: nuumber, b: number) { return a + b }
function sub(a: nuumber, b: number) { return a - b }
function mul(a: nuumber, b: number) { return a * b }
function div(a: nuumber, b: number) { return a / b }

// 요래됐슴다
type BinaryFn = (a: number, b: number) => number;
const add: BinaryFn = (a, b) => a + b;
const sub: BinaryFn = (a, b) => a - b;
const mul: BinaryFn = (a, b) => a * b;
const div: BinaryFn = (a, b) => a / b;
```

---

### fetch 함수 선언을 표현식으로 변경하는 예시
```typescript
// 얘도 이랬는데
asnyc function getQuote() {
  const response = await fetch('/quote?by=Mark+Twain')
  const quote = await response.json()
  return quote;
}

// 요래됐슴당
// typeof fetch로 input, init의 타입도 같이 추론된다
const checkedFetch: typeof fetch = async (input, init) => {
  const response = await fetch(input, init)
  if (!response.ok) {
    throw new Error('Requrest failed: ' + response.status)
  }
  return response
}
```

---

### 차이점
- 함수 선언은 함수의 호출 위치에서 에러가 발생한다.
- 함수 전체 타입을 정의하면 선언 내에서 오류가 발생한다.

---

## 아이템 13 타입과 인터페이스의 차이점 알기

TS의 명명된 타입 정의 방법: 타입, 인터페이스
```typescript
type TState = {
  name: string;
  capital: string;
}

interface IState {
  name: string;
  capital: string;
}
```
두 개의 차이를 분명히 알고, 상황별 일관성을 유지해야 한다.

---

### 비슷한 점
1. 인덱스 시그니처를 사용할 수 있다.
```typescript
type TDict = { [key: string]: string }
interface IDict {
  [key: string]: string
}
```
2. 함수 타입을 정의할 수 있다.
```typescript
type TFn = (x: number) => string
interface IFn {
  (x: number): string
}
```

---

### 비슷한 점
3. 제너릭이 가능하다
```typescript
type TPair<T> = {
  first: T;
  second: T;
}

interface IPair<T> {
  first: T;
  second: T;
}
```

---

### 비슷한 점
4. 서로를 확장할 수 있다.(주의사항은 있음)
```typescript
interface IStateWithPop extends TState {
  population: number;
}
type TStateWithPop = IState & { population: number };
```
**주의사항**: 인트페이스는 유니온 타입 같은 복잡한 타입을 확장할 수 없다.
별개로 클래스(implements)를 구현할 때는 둘 다 사용 가능하다.

---

### 다른 점
1. 유니온 타입은 있지만 유니온 인터페이스는 없다.
2. 인터페이스는 타입을 확장할 수 있지만, 유니온은 할 수 없다.
```typescript
type Input = { ... }
type Output = { ... }
interface VariableMap {
  [name: string]: Input | Output;
}
// 유니온 타입의 확장
type NameVariable = (Input | Output) & { name: string };
```

---

